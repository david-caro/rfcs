# Meta
[meta]: #meta
- Name: Export to OCI format
- Start Date: 2022-02-22
- Author(s): Juan Bustamante (@jjbustamante)
- Status: Draft <!-- Acceptable values: Draft, Approved, On Hold, Superseded -->
- RFC Pull Request: (leave blank)
- CNB Pull Request: (leave blank)
- CNB Issue: (leave blank)
- Supersedes: (put "N/A" unless this replaces an existing RFC, then link to that RFC)

# Summary
[summary]: #summary

Add the capability to the `Exporter` phase to save the image to disk in [OCI Layout](https://github.com/opencontainers/image-spec/blob/main/image-layout.md) format.

# Definitions
[definitions]: #definitions

- A [Platform](https://buildpacks.io/docs/concepts/components/platform/) uses a lifecycle, Buildpacks (packaged in a builder), and application source code to produce an OCI image.
- A [Lifecycle](https://buildpacks.io/docs/concepts/components/lifecycle/) orchestrates Buildpacks execution, then assembles the resulting artifacts into a final app image.
- A **Daemon** is a service, popularized by Docker, for downloading container images, and executing and managing containers from those images.
- A **Registry** is a long-running service used for storing and retrieving container images.
- An **image reference** refers to either a tag reference or digest reference.
- A **tag reference** refers to an identifier of form `<registry>/<repo>:<tag>` which locates an image manifest in an [OCI Distribution Specification](https://github.com/opencontainers/distribution-spec/blob/master/spec.md) compliant registry.
- A **digest reference** refers to a [content addressable](https://en.wikipedia.org/wiki/Content-addressable_storage) identifier of form `<registry>/<repo>@<digest>` which locates an image manifest in an [OCI Distribution Specification](https://github.com/opencontainers/distribution-spec/blob/master/spec.md) compliant registry.
- A **image Manifest** provides a configuration and set of layers for a single container image for a specific architecture and operating system.
- The **layer diffID** is the hash of the uncompressed layer
- The **layer digest** is the hash of the compressed layer.
- An [OCI Image Layout](https://github.com/opencontainers/image-spec/blob/main/image-layout.md) is the directory structure for OCI content-addressable blobs and [location-addressable](https://en.wikipedia.org/wiki/Content-addressable_storage#Content-addressed_vs._location-addressed) references.

# Motivation
[motivation]: #motivation

### Why should we do this?

Lifecycle translates an application source code into an OCI image, in order to do this, it can be configured to interact with a docker daemon (using `daemon` flag) or with an OCI registry.

The [OCI Image Layout](https://github.com/opencontainers/image-spec/blob/main/image-layout.md) is the directory structure for OCI content-addressable blobs and [location-addressable](https://en.wikipedia.org/wiki/Content-addressable_storage#Content-addressed_vs._location-addressed) references.

The current process, executed by the lifecycle, does not take into consideration cases where a platform implementor may require to pass through the inputs or want to save the final application image on disk using [OCI Image Layout](https://github.com/opencontainers/image-spec/blob/main/image-layout.md) format.

### What use cases does it support?

Exporting to [OCI Image Layout](https://github.com/opencontainers/image-spec/blob/main/image-layout.md) will enable new user's workflows on top of this functionality. For example:
  - Reduce the Lifecycle complexity removing the interaction with the Daemon.
  - Solve the problem of losing information when the image is saved into the Daemon, keeping the image on disk along with the metadata generated by the Lifecycle. The OCI Image can be used as input for other tools to offer more capabilities to the end users.
  - This feature will help to unblock uses cases like
    - OCI annotations. See [RFC](https://github.com/buildpacks/rfcs/pull/196)
    - Cosign integration. See [RFC](https://github.com/buildpacks/rfcs/pull/195)
    - Export to tarball. See [issue](https://github.com/buildpacks/lifecycle/issues/423)

### What is the expected outcome?

Lifecycle will be capable of exporting application image into disk in [OCI Image Layout](https://github.com/opencontainers/image-spec/blob/main/image-layout.md) format.

# What it is
[what-it-is]: #what-it-is

The proposal is to add a new capability to the lifecycle (enabled by configuration) to resolve any **image reference** (input or output) to a disk location in [OCI Image Layout](https://github.com/opencontainers/image-spec/blob/main/image-layout.md) format. It means, instead of interacting with a daemon or registry lifecycle will interact against the filesystem to read or write any **image reference**.

The target personas affected by this change are:

- **Platform implementors**: they will have to take care of the responsibility of creating a store resource on disk in [OCI Image Layout](https://github.com/opencontainers/image-spec/blob/main/image-layout.md) format and pass it through the lifecycle during the phases execution.  

Let's see some examples of the proposed behavior

## Examples

### Requirements

A folder on disk (accessible by the lifecycle) is required to execute the feature, this new folder works as a local registry and the content must be in [OCI Image Layout](https://github.com/opencontainers/image-spec/blob/main/image-layout.md) format.

Lifecycle phases accepts arguments pointing to `image reference`, those arguments are:

| Input | Description
|-------|------------
| `<image>`	|	Tag reference to which the app image will be written |
| `<previous-image>` | Image reference to be analyzed  (usually the result of the previous build) |
| `<run-image>`	| Run image reference |

<!-- | `<cache-image>`	| Reference to a cache image in an OCI image registry | -->

Let's suppose a directory exits and it has the following structure:

```=shell
oci
├── cnb
│   └── my-stack-run
│       ├── blobs
│       │   └── sha256
│       │       └── 1bcd..x
│       ├── index.json
│       └── oci-layout
├── foo
│   └── my-cache
│       ├── blobs
│       │   └── sha256
│       │       └── 1f591..a
│       ├── index.json
│       └── oci-layout
└── bar
    └── my-previous-app
        ├── blobs
        │   └── sha256
        │       └── 1efg..w
        ├── index.json
        └── oci-layout
```

For each case, I will present two ways of enabling the new capability:

- Using an environment Variable
- Using a new `oci` flag

In any case the expected output is the same.

#### Analyze phase

##### Analyzing run-image

```=shell
> export CNB_USE_OCI=true
> /cnb/lifecycle/analyzer -run-image cnb/my-stack-run:bionic my-app-image

# OR

> /cnb/lifecycle/analyzer -oci -run-image cnb/my-stack-run:bionic my-app-image

# expected output
# analyzed.toml file with the usual `run-image.reference`

```

##### Analyzing previous-image

 ```=shell
> export CNB_USE_OCI=true
> /cnb/lifecycle/analyzer -run-image cnb/my-stack-run:bionic -previous-image bar/my-previous-app my-app-image

# OR

> /cnb/lifecycle/analyzer -oci -run-image cnb/my-stack-run:bionic-previous-image bar/my-previous-app my-app-image

# expected output
# analyzed.toml file with the usual `run-image.reference` and `previos-image.reference`
```
<!--
##### Analyzing using cache-image

```=shell
> export CNB_USE_OCI=true
> /cnb/lifecycle/analyzer -run-image cnb/my-stack-run:bionic -cache-image foo/my-cache my-app-image

# OR

> /cnb/lifecycle/analyzer -oci -run-image cnb/my-stack-run:bionic -cache-image foo/my-cache my-app-image

# expected output
# analyzed.toml file with the usual `run-image.reference`

```

-->

##### Analyzing run-image not saved on disk

```=shell
> export CNB_USE_OCI=true
> /cnb/lifecycle/analyzer -run-image cnb/bad-run-image my-app-image

# OR

> /cnb/lifecycle/analyzer -oci -run-image cnb/bad-run-image my-app-image

# expected output

ERROR: the run-image could not be found at path: /oci/cnb/bad-run-image
```

##### Analyzing without run-image argument

```=shell
> export CNB_USE_OCI=true
> /cnb/lifecycle/analyzer my-app-image

# OR

> /cnb/lifecycle/analyzer -oci my-app-image

# expected output

ERROR: -run-image is required when OCI feature is enabled
```

#### Export phase

##### Export to OCI


```=shell
> export CNB_USE_OCI=true
> /cnb/lifecycle/exporter -run-image cnb/my-stack-run:bionic my-app-image

# OR

>  /cnb/lifecycle/exporter -oci -run-image cnb/my-stack-run:bionic my-app-image

# expected output
# the store folder will be updated with the application image as follows

oci
├── cnb
│   └── my-stack-run
│       ├── blobs
│       │   └── sha256
│       │       └── 1bcd..x
│       ├── index.json
│       └── oci-layout
├── foo
│   └── // omiting for simplicity
├── bar
│   └── // omiting for simplicity
└── my-app-image
    └── blobs
        ├── sha256
        │   ├── 1bcd..x
        │   ├── 2f789..d
        │   └── 3g234..f
        ├── index.json
        └── oci-layout

```

##### Using -oci flag in combination with --daemon or --publish flags

Any combination of using multiple sources or sinks in the Lifecycle invocation of phases should throw an error to the user. For example:

```=shell
> export CNB_USE_OCI=true
> /cnb/lifecycle/exporter -daemon -run-image cnb/my-stack-run:bionic my-app-image

# OR

> /cnb/lifecycle/exporter -oci -daemon -run-image cnb/my-stack-run:bionic my-app-image

ERROR: exporting to multiples target is not allowed
```

# How it Works
[how-it-works]: #how-it-works

The lifecycle phases affected by this new behavior are:
 - [Analyze](https://buildpacks.io/docs/concepts/components/lifecycle/analyze/)
 - [Restore](https://buildpacks.io/docs/concepts/components/lifecycle/restore/)
 - [Export](https://buildpacks.io/docs/concepts/components/lifecycle/export/)  
 - [Create](https://buildpacks.io/docs/concepts/components/lifecycle/create/)

At a high level view the proposed solution can be summarized with the following system landscape diagram from the C4 model

![](https://i.imgur.com/y972lTD.png)

Notice that we are relying on the OCI format Specification to expose the data for `Platforms`

The following new inputs are proposed to be added to these phases

 | Input | Environment Variable  | Default Value | Description
 |-------|-----------------------|---------------|--------------
 | `<oci>`      |  `CNB_USE_OCI` | false | Analyze or Export image from/to OCI layout format on disk |
 | `<oci-dir>` | `CNB_OCI_PATH` | /oci | Path to oci directory where the images are saved |

- WHEN `the new flag -oci or the default environment variable CNB_USE_OCI are set to true` during the phase invocation THEN the feature will be enabled.
The image look up will be done following these rules:
  - WHEN `the image points to a tag reference`
    - Lifecycle will load the image from disk in [OCI Image Layout](https://github.com/opencontainers/image-spec/blob/main/image-layout.md) format at `<oci-dir>/<registry>/<repo>/<tag>`
  - WHEN `the image points to a digest reference`
    - Lifecycle will load the image from disk in [OCI Image Layout](https://github.com/opencontainers/image-spec/blob/main/image-layout.md) format at `<oci-dir>/<registry>/<repo>/<digest>`
  - Apart from the look up, the logic for each phase should remain the same




## Proof of concept

In order to validate the feasibility of the proposed feature, we developed a proof of concept with one of the most important side effects this capability can add into the project: **Removing the Daemon Support**. You can also check a recording with the demo in the following [link](https://drive.google.com/file/d/1W1125OHuyUlx88BRroUTLBfrFHhFM5A9/view?usp=sharing)

As mentioned earlier, if we want to remove the daemon support in the Lifecycle, then all the responsibility to deal with it goes into the platforms implementors, that means, for example:
- Pull the require dependencies (runtime image for example), save them on disk in OCI layout format and pass it through the lifecycle using the `<oci-dir>` parameter
- Push the application image (exported in OCI layout format) into the Daemon, because that is what users are expecting.

During the proof of concept implementation I choose to use [skopeo](https://github.com/containers/skopeo) tool to solve the problem of interacting with the Daemon. The reason to do it was **simplicity** for the PoC developed but we believe this is a good subject to talk about with the community.

The following workflow was developed:
- Pack download the [skopeo image](https://github.com/containers/skopeo/blob/main/install.md#container-images), similar as it is downloading the other dependencies (Lifecycle, Buildpacks)
- Pack executes [skopeo copy](https://github.com/containers/skopeo/blob/main/docs/skopeo-copy.1.md)  command in a container
  - Copy image from the Daemon into the filesystem, in OCI layout format, before running Lifecycle
  - Copy image from filesystem into the Daemon after the export phase was executed

The following Dynamic Diagram from the C4 model, can give a little idea of the pieces implemented during the Poc

![](https://i.imgur.com/SkY3l62.png)

### Measuring of performance impact

In order to have an idea on how much is affected the performance of exporting to the Daemon using the OCI layout format, the following metrics were taken.

Using a local workstation with the following specifications:
- **(MacOS 12.3.1 / 2,4 GHz 8-Core Intel Core i9 / 32 GB 2667 MHz DDR4 / 1 TB APFS SSD HD)**

We built 5 times the Java, Kotlin and Ruby samples codes from our [repository](https://github.com/buildpacks/samples/tree/main/apps) and took the building's average time using the Daemon and the OCI layout format approaches.

The table above summarized the results we got.

![](https://i.imgur.com/zuPZ6Xk.png)

Times are expressed in **seconds** and the first thing we noticed is for Java and Kotlin the `build time` can be affected by the network and the availability of maven repositories, so I decided to take the `same build time` to compare both approaches.

Here are my thoughts about these results:
- Java and Kotlin behavior are very similar, exporting only to OCI format increases 5% the time compared to Daemon approach, and from user perspective it represents a 5 seconds increase of time.
- On the other hand for the Ruby application, exporting to OCI format represents a  20% increase of the time but from user perspective it is only 1.5 seconds which is probably difficult to notice from user perspective.
- When the time spent for Pack to prepare the environment for the lifecycle execution (downloading the run-image from a registry to OCI format) and loading the OCI image from disk to the Daemon (which is the expected behavior from Users) is added, then:
  - The Java and Kotlin applications time increases was **13%**, representing **+13 seconds** from user perspective
  - The Ruby application increases **82%** but from user's side it represents **+7 seconds**

Let's take a look on what happened when we execute a build for the second time, the table below summarized the results

![](https://i.imgur.com/zDAOZU6.png)

On these cases we can see the behavior is consistent compared with the previous case, Java and Kotlin application shows a **5% increase** of time but Ruby application, because it's process time is smaller the sensibility to variation is bigger (23%) but in reality it represents a **+1 second** of difference for the User. Also, when the pre and post processing time is added the variations are bigger for all the applications. As mentioned, [skopeo](https://github.com/containers/skopeo) tool was used here and most of the time spent goes into this category.

I think, this PoC demonstrate that adding the exporting to OCI layout format is a valuable feature for the project, it opens the door to deprecate the use of Daemon but it will requires that platform implementors to prepare and post-process the output on disk on a smart way to reduce the performance penalties to users.

# Migration
[migration]: #migration

## For the scope of this RFC

- No breaking changes were identified

# Drawbacks
[drawbacks]: #drawbacks

- We could increase the disk space if we do not manage the duplication of saving the layers on disk. The proposal suggests to use symbolic links to reference layers on disk and avoid duplication.

# Alternatives
[alternatives]: #alternatives

- What other designs have been considered?
  - Doing nothing, just keep exporting only to Daemon or Registry

- What other designs have been considered for removing the Daemon support?
  - Instead of exporting to OCI layout format, the other approach considered is exporting to [registry only](https://github.com/buildpacks/rfcs/blob/jjbustamante/feature/deprecate-daemon/text/0000-deprecate-daemon.md#lifecycle-registry-only-approach). In this case, the Lifecycle only interacts with registries.
   As part of the PoC, I took some metrics to compare impact of using a ephemeral registry to publish the application image. The strategy done to capture the metrics was:
    - I used a script to set up a local [container registry](https://hub.docker.com/_/registry) before executing the `pack build` command
    - For the **first build** metrics, the registry was destroyed/re-created before each execution
    - `pack build` command was configure to `--publish` in the local registry
    - I didn't use the [skopeo]() in these cases to complete the pushing into the Daemon

  Here are the results:

    ![](https://i.imgur.com/vtOjxJP.png)

     -  The results are actually very similar to exporting to OCI layout format for Java and Kotlin, but Ruby application is actually worst.

    ![](https://i.imgur.com/FfbqfF6.png)

     - Second build is actually better compared with the export to OCI in disk, Java and Kotlin increases the time just by **2%**, but Ruby again is worst

  Some thoughts about this approaches

    - **Process Management:** Platforms must now manage a parallel process (registry in the daemon). This would entail ensuring that the registry is started and cleaned up appropriately.
    - **Networking:** There are additional network complications in order to route images to the ephemeral registry. For example, [network drivers](https://docs.docker.com/network/#network-drivers), [proxy](https://docs.docker.com/desktop/networking/#httphttps-proxy-support) and [DNS configuration](https://docs.docker.com/config/containers/container-networking/#dns-services), [host name resolution](https://docs.docker.com/desktop/networking/#i-want-to-connect-from-a-container-to-a-service-on-the-host), and [TLS certificates](https://betterprogramming.pub/deploy-a-docker-registry-using-tls-and-htpasswd-56dd57a1215a) to name a few.

- Why is this proposal the best? [OCI Image Layout](https://github.com/opencontainers/image-spec/blob/main/image-layout.md) format is a standard from which other tools can create a [OCI Runtime Specification bundle](https://github.com/opencontainers/runtime-spec/blob/v1.0.0/bundle.md) exporting to this format enables Platforms to implement any feature in the top of this format, for example, exporting to [containerd](https://containerd.io) has been [requested](https://github.com/buildpacks/lifecycle/issues/829) by the community and it could be implemented if we can get the application image exported in [OCI Image Layout](https://github.com/opencontainers/image-spec/blob/main/image-layout.md) format.
- What is the impact of not doing this? Probably will never remove the Daemon support in the Lifecycle

# Prior Art
[prior-art]: #prior-art

- Discussion around removing the Daemon support [RFC](https://github.com/buildpacks/rfcs/blob/jjbustamante/feature/deprecate-daemon/text/0000-deprecate-daemon.md)

# Unresolved Questions
[unresolved-questions]: #unresolved-questions

<!--
- What parts of the design do you expect to be resolved before this gets merged?
- What parts of the design do you expect to be resolved through implementation of the feature?
- What related issues do you consider out of scope for this RFC that could be addressed in the future independently of the solution that comes out of this RFC? -->

# Spec. Changes (OPTIONAL)
[spec-changes]: #spec-changes

<!--
Does this RFC entail any proposed changes to the core specifications or extensions? If so, please document changes here.
Examples of a spec. change might be new lifecycle flags, new `buildpack.toml` fields, new fields in the buildpackage label, etc.
This section is not intended to be binding, but as discussion of an RFC unfolds, if spec changes are necessary, they should be documented here. -->
