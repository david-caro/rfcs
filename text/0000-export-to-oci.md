# Meta
[meta]: #meta
- Name: Export to OCI format
- Start Date: 2022-02-22
- Author(s): Juan Bustamante (@jbustamante)
- Status: Draft <!-- Acceptable values: Draft, Approved, On Hold, Superseded -->
- RFC Pull Request: (leave blank)
- CNB Pull Request: (leave blank)
- CNB Issue: (leave blank)
- Supersedes: (put "N/A" unless this replaces an existing RFC, then link to that RFC)

# Summary
[summary]: #summary

Add the capability to the `Exporter` phase to save the image to disk in [OCI Layout](https://github.com/opencontainers/image-spec/blob/main/image-layout.md) format.

# Definitions
[definitions]: #definitions

- A [Platform](https://buildpacks.io/docs/concepts/components/platform/) uses a lifecycle, Buildpacks (packaged in a builder), and application source code to produce an OCI image.
- A [Lifecycle](https://buildpacks.io/docs/concepts/components/lifecycle/) orchestrates Buildpacks execution, then assembles the resulting artifacts into a final app image.
- A **Daemon** is a service, popularized by Docker, for downloading container images, and executing and managing containers from those images.
- A **Registry** is a long-running service used for storing and retrieving container images.
- An **image reference** refers to either a tag reference or digest reference.
- A **tag reference** refers to an identifier of form `<registry>/<repo>:<tag>` which locates an image manifest in an [OCI Distribution Specification](https://github.com/opencontainers/distribution-spec/blob/master/spec.md) compliant registry.
- A **digest reference** refers to a [content addressable](https://en.wikipedia.org/wiki/Content-addressable_storage) identifier of form `<registry>/<repo>@<digest>` which locates an image manifest in an [OCI Distribution Specification](https://github.com/opencontainers/distribution-spec/blob/master/spec.md) compliant registry.
- A **image Manifest** provides a configuration and set of layers for a single container image for a specific architecture and operating system.
- An [OCI Image Layout](https://github.com/opencontainers/image-spec/blob/main/image-layout.md) is the directory structure for OCI content-addressable blobs and location-addressable references.

# Motivation
[motivation]: #motivation

Exporting to [OCI Image Layout](https://github.com/opencontainers/image-spec/blob/main/image-layout.md) will enable new user's workflows on top of this functionality. For example:
  - Reduce the Lifecycle complexity removing the interaction with the Daemon.
  - Solve the problem of losing information when the image is saved into the Daemon, keeping the image on disk along with the metadata generated by the Lifecycle. The OCI Image can be used as input for other tools to offer more capabilities to the end users.
  - This feature will help to unblock uses cases like
    - OCI annotations. See [RFC](https://github.com/buildpacks/rfcs/pull/196)
    - Cosign integration. See [RFC](https://github.com/buildpacks/rfcs/pull/195)

# What it is
[what-it-is]: #what-it-is

The target persona affected by this change are:

- **Platform implementors**: they will have to take care of the responsibility of:
  - Pull the require dependencies (runtime image for example) and pass it through the lifecycle

The general idea is to produce an image in [OCI Image Layout](https://github.com/opencontainers/image-spec/blob/main/image-layout.md) format and save it in a file system accesible from the lifecycle execution.

Let's see some examples of the proposed behavior

## Examples

For each case, I will present two ways of invoking the new feature:

- Using the environment Variable
- Using the new flag

For both ways the expected output is the same

### Analyzing run-image from OCI layout format

Let's suppose the `<oci-dir>` or `CNB_OCI_PATH` environment variable points to a  directory that contains the `run-image` with the following format

```=shell
oci
├── cnbs
   └── sample-stack-run
       ├── blobs
       │   └── sha256
       │       ├── 1f59171fcf9a8c2a78192d4dfbf88e6f0258e24f21798ffe015c07682d3a944a
       │       ├── 219480c73c20efd82d425207e7555eba09cb113c845250cef09ba376e1dd506e
       │       ├── 63882e64890d1adea5824dbb9bc6a812140d6b85752bf74a0a26fca78e1baf5a
       │       ├── 63cb781c9d22ed765584437fea6db568f79be248ce40fc6695017d3ef3e8caaa
       │       └── 6b534265b45a4c09a5e05dde5ccf2450ea505481658a1c9ae9e0aae32362e941
       ├── index.json
       └── oci-layout
```

And the analyzer is invoked as follows

```=shell
> export CNB_USE_OCI=true
> /cnb/lifecycle/analyzer -run-image cnbs/sample-stack-run:bionic my-app-image
```

Or

```=shell
> /cnb/lifecycle/analyzer -oci -run-image cnbs/sample-stack-run:bionic my-app-image
```

The expected output is the analysis metadata [analyzed.toml](https://github.com/buildpacks/spec/blob/main/platform.md#analyzedtoml-toml) with a content similar to this one:

```=TOML
[run-image]
  reference = "sha256:eed6d69be53111ad1d7d3f5d1c037350e6807986feb479a67f36b15f9205a56d"
```

Where the [ImageID](https://github.com/opencontainers/image-spec/blob/main/config.md#imageid) is calculated according to the OCI specification


### Exporting to OCI layout format

Similar to the previous example, let's suppose the `<oci-dir>` or `CNB_OCI_PATH` environment variable points to a  directory that contains the `run-image` with the following format

```=shell
oci
├── cnbs
   └── sample-stack-run
       ├── blobs
       │   └── sha256
       │       ├── 1f59171fcf9a8c2a78192d4dfbf88e6f0258e24f21798ffe015c07682d3a944a
       │       ├── 219480c73c20efd82d425207e7555eba09cb113c845250cef09ba376e1dd506e
       │       ├── 63882e64890d1adea5824dbb9bc6a812140d6b85752bf74a0a26fca78e1baf5a
       │       ├── 63cb781c9d22ed765584437fea6db568f79be248ce40fc6695017d3ef3e8caaa
       │       └── 6b534265b45a4c09a5e05dde5ccf2450ea505481658a1c9ae9e0aae32362e941
       ├── index.json
       └── oci-layout
```

And the exporter is invoked as follows

```=shell
> export CNB_OCI_PATH=true
> /cnb/lifecycle/exporter -run-image cnbs/sample-stack-run:bionic my-app-image
```

Or

```=shell
>  /cnb/lifecycle/exporter -oci -run-image cnbs/sample-stack-run:bionic my-app-image
```

The expected output is the application `<image>` exported in [OCI Image Layout](https://github.com/opencontainers/image-spec/blob/main/image-layout.md) format

```=shell
├── cnbs
│   └── sample-stack-run
│       ├── blobs
│       │   └── sha256
│       │       ├── 1f59171fcf9a8c2a78192d4dfbf88e6f0258e24f21798ffe015c07682d3a944a
│       │       ├── 219480c73c20efd82d425207e7555eba09cb113c845250cef09ba376e1dd506e
│       │       ├── 63882e64890d1adea5824dbb9bc6a812140d6b85752bf74a0a26fca78e1baf5a
│       │       ├── 63cb781c9d22ed765584437fea6db568f79be248ce40fc6695017d3ef3e8caaa
│       │       └── 6b534265b45a4c09a5e05dde5ccf2450ea505481658a1c9ae9e0aae32362e941
│       ├── index.json
│       └── oci-layout
└── my-app-image
    ├── blobs
    │   └── sha256
    │       ├── 14eaea7168b1fc4b8b30f7a20f7609335cc3dbcfb6d4c1afeb1e5daefd26cdf9
    │       ├── 219480c73c20efd82d425207e7555eba09cb113c845250cef09ba376e1dd506e -> ../../../cnbs/sample-stack-run/blobs/sha256/219480c73c20efd82d425207e7555eba09cb113c845250cef09ba376e1dd506e
    │       ├── 410ce2030625414163d565a56bddc6587dbc49fa2a815af5e26bb08968dec7d2
    │       ├── 54890b0245f8b234be46817f731b7b981d9ee2ea8d5a76380d91bb9abb001cdb
    │       ├── 58b81a67d77e732ef07c4b995b6a7e099e5aa772d1805da7cf929d80a3fa044e
    │       ├── 63cb781c9d22ed765584437fea6db568f79be248ce40fc6695017d3ef3e8caaa -> ../../../cnbs/sample-stack-run/blobs/sha256/63cb781c9d22ed765584437fea6db568f79be248ce40fc6695017d3ef3e8caaa
    │       ├── 68224c8aa806b9ec8cecf2282b7b10cdf1c615785652bcc85f3a79bd06e60384
    │       ├── 6977801a3b8ac0c4a76ea22fa4dc0541fe8fc6ba964883ee0a21b5736f8acee9
    │       ├── 6b534265b45a4c09a5e05dde5ccf2450ea505481658a1c9ae9e0aae32362e941 -> ../../../cnbs/sample-stack-run/blobs/sha256/6b534265b45a4c09a5e05dde5ccf2450ea505481658a1c9ae9e0aae32362e941
    │       ├── 7c83d7d24ac43dbdd419d15abb849b6d155d0bc361eca0908a8ae5aefcd55557
    │       └── addd2357f3a0175410ab8f9303e747cc72af9aaeb0e7402d3fd3f144adb29db5
    ├── index.json
    └── oci-layout
```

Also, we are proposing to use symbolic links to reference the blobs from the `run-image` as this will help to save some hard drive space for the end user.

### Using -oci flag in combination with --daemon or --publish flags

Any combination of using multiple sources or sinks in the Lifecycle invocation of phases should throw an error to the user. For example:

```=shell
> /cnb/lifecycle/exporter -oci -daemon -run-image cnbs/sample-stack-run:bionic my-app-image

ERROR: exporting to multiples target is not allowed
```

# How it Works
[how-it-works]: #how-it-works

The lifecycle phases affected by this new behavior are:
 - [Analyze](https://buildpacks.io/docs/concepts/components/lifecycle/analyze/)
 - [Export](https://buildpacks.io/docs/concepts/components/lifecycle/export/)  
 - [Create](https://buildpacks.io/docs/concepts/components/lifecycle/create/)

At a high level view the proposed solution can be summarized with the following system landscape diagram from the C4 model

![](https://i.imgur.com/y972lTD.png)

Notice that we are relying on the OCI format Specification to expose the data for `Platforms`

The following new inputs are proposed to be added to these phases

 | Input             | Environment Variable  | Default Value            | Description
 |-------------------|-----------------------|--------------------------|----------------------
 | `<oci>`      |  `CNB_USE_OCI` | false | Analyze or Export image from/to OCI layout format on disk |
 | `<oci-dir>` | `CNB_OCI_PATH` | /oci | Path to oci directory where the images are saved |

- WHEN `the new flag -oci or the default environment variable CNB_USE_OCI are set to true` during the phase invocation THEN the feature will be enabled.
The image look up will be done following these rules:
  - WHEN `the image points to a tag reference`
    - Lifecycle will load the image from disk in [OCI Image Layout](https://github.com/opencontainers/image-spec/blob/main/image-layout.md) format at `<oci-dir>/<registry>/<repo>/<tag>`
  - WHEN `the image points to a digest reference`
    - Lifecycle will load the image from disk in [OCI Image Layout](https://github.com/opencontainers/image-spec/blob/main/image-layout.md) format at `<oci-dir>/<registry>/<repo>/<digest>`
  - Apart from the look up, the logic for each phase should remain the same

## Proof of concept

In order to validate the feasibility of the proposed feature, we developed a proof of concept with one of the most important side effects this capability can add into the project: **Removing the Daemon Support**

As mentioned earlier, if we want to remove the daemon support in the Lifecycle, then all the responsibility to deal with it goes into the platforms implementors, that means, for example:
- Pull the require dependencies (runtime image for example), save them on disk in OCI layout format and pass it through the lifecycle using the `<oci-dir>` parameter
- Push the application image (exported in OCI layout format) into the Daemon, because that is what users are expecting.

During the proof of concept implementation I choose to use [skopeo](https://github.com/containers/skopeo) tool solve problem interacting with the Daemon. The reason to do it was **simplicity** for the PoC developed but we believe this is a good subject to talk about with the community.

The following workflow was developed:
- Pack download the [skopeo image](https://github.com/containers/skopeo/blob/main/install.md#container-images), similar as it is downloading the other dependencies (Lifecycle, Buildpacks)
- Pack executes [skopeo copy](https://github.com/containers/skopeo/blob/main/docs/skopeo-copy.1.md)  command in a container
  - Copy image from the Daemon into the filesystem, in OCI layout format, before running Lifecycle
  - Copy image from filesystem into the Daemon after the export phase was executed

The following Dynamic Diagram from the C4 model, can give a little idea of the pieces implemented during the Poc

![](https://i.imgur.com/SkY3l62.png)

You can also check a demo recording in the following [link](https://drive.google.com/file/d/1W1125OHuyUlx88BRroUTLBfrFHhFM5A9/view?usp=sharing)


# Migration
[migration]: #migration

- No breaking changes were identified

# Drawbacks
[drawbacks]: #drawbacks

- We could increase the disk space if we do not manage the duplication of saving the layers on disk. The proposal suggests to use symbolic links to reference layers on disk and avoid duplication.

# Alternatives
[alternatives]: #alternatives

- What other designs have been considered?
  - Doing nothing, just keep exporting only to Daemon or Registry
- Why is this proposal the best? [OCI Image Layout](https://github.com/opencontainers/image-spec/blob/main/image-layout.md) format is a standard from which other tools can create a [OCI Runtime Specification bundle](https://github.com/opencontainers/runtime-spec/blob/v1.0.0/bundle.md) exporting to this format enables Platforms to implement any feature in the top of this format
- What is the impact of not doing this? Probably will never remove the Daemon support in the Lifecycle

# Prior Art
[prior-art]: #prior-art

- Discussion around removing the Daemon support [RFC](https://github.com/buildpacks/rfcs/blob/jjbustamante/feature/deprecate-daemon/text/0000-deprecate-daemon.md)

# Unresolved Questions
[unresolved-questions]: #unresolved-questions


<!--
- What parts of the design do you expect to be resolved before this gets merged?
- What parts of the design do you expect to be resolved through implementation of the feature?
- What related issues do you consider out of scope for this RFC that could be addressed in the future independently of the solution that comes out of this RFC? -->

# Spec. Changes (OPTIONAL)
[spec-changes]: #spec-changes

<!--
Does this RFC entail any proposed changes to the core specifications or extensions? If so, please document changes here.
Examples of a spec. change might be new lifecycle flags, new `buildpack.toml` fields, new fields in the buildpackage label, etc.
This section is not intended to be binding, but as discussion of an RFC unfolds, if spec changes are necessary, they should be documented here. -->
